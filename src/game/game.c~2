#include <ncurses.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <signal.h>
#include <unistd.h>
#include "game.h"
#include "game_parameter.h"   // WIDTH, HEIGHT, MAX_BULLETS, MAX_OBSTACLES ë“± ì •ì˜
#include "intro_ui.h"          // init_colors(), show_main_menu(), func_pause(), end_by_signal(), ë“±
#include "common.h"
#include "controller.h"
pthread_mutex_t score_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t render_mutex = PTHREAD_MUTEX_INITIALIZER;  // ë Œë”ë§ ë³´í˜¸ìš© ë®¤í…ìŠ¤

//ì»¨íŠ¸ë¡¤ëŸ¬ìš©
char imu_direction[3] = {'5', '0', '0'};
pthread_mutex_t switch_lock;  
pthread_mutex_t imu_lock = PTHREAD_MUTEX_INITIALIZER;
pthread_t imu_thread;
// ì•„ì´í…œ ê´€ë ¨ ì •ì˜ ìˆ˜ì •
#define MAX_ITEMS 5
typedef struct {
    int x;
    int y;
    int type; // 0: Clear All, 1: Bomb
    int active;
} Item;

Item items[MAX_ITEMS];
int effect_timer = 0; // ì´í™íŠ¸ í‘œì‹œ íƒ€ì´ë¨¸
int effect_type = -1; // 0: Clear All, 1: Bomb
int has_item = -1; // -1: No item, 0: Clear All, 1: Bomb (global variable)
// ìƒ‰ìƒ ì •ì˜
#define COLOR_PLAYER    1
#define COLOR_BULLET    2
#define COLOR_OBSTACLE  3
#define COLOR_LIFE      4
#define COLOR_BORDER    5
#define COLOR_UI        6
#define COLOR_SCORE     7
#define COLOR_ENEMY     8

extern int seed; //networkë¡œ ë¶€ì—¬ë°›ì€ seed

// ì „ì—­ ê²Œì„ ë³€ìˆ˜ë“¤
int player_x, player_y;           // í”Œë ˆì´ì–´ ìœ„ì¹˜
int life = 3;                     // ë‚¨ì€ ëª©ìˆ¨
int score = 0;                    // ì ìˆ˜
int game_over = 0;                // ê²Œì„ ì¢…ë£Œ í”Œë˜ê·¸
int paused = 0;                   // ì¼ì‹œì •ì§€ í”Œë˜ê·¸
int current_key = -1;             // ì…ë ¥ í‚¤ ì €ì¥ (ë¯¸ì‚¬ìš©)
Bullet bullets[MAX_BULLETS];      // ë°œì‚¬ì²´ ë°°ì—´
Obstacle obstacles[MAX_OBSTACLES];// ì¥ì• ë¬¼ ë°°ì—´

//ê²Œì„ ë‚œì´ë„ ì¡°ì •ì„ ìœ„í•œ ë³€ìˆ˜ë“¤
int level = 1;                     // í˜„ì¬ ë ˆë²¨
int obstacle_interval = 20;        // ì¥ì• ë¬¼ ì´ë™ ì£¼ê¸° (í”„ë ˆì„ ë‹¨ìœ„)
int spawn_interval    = 10;        // ì¥ì• ë¬¼ ìƒì„± ì£¼ê¸° (í”„ë ˆì„ ë‹¨ìœ„)
int item_spawn_interval = 10;
// ê²Œì„ ëŒ€ê¸° ìƒíƒœ ë³€ìˆ˜ ì¶”ê°€
int waiting_for_opponent = 0;     // ìƒëŒ€ë°© ì¢…ë£Œ ëŒ€ê¸° ì¤‘ì¸ì§€ í‘œì‹œ

//ë”ë¸” ë²„í¼ë§ì„ ìœ„í•œ ë³€ìˆ˜ë“¤
/**
 * game_win, un_winìœ¼ë¡œ í™”ë©´ì„ ë¶„ë¦¬í•˜ì—¬ ê°ê° ë…ë¦½ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸
 * ê¹œë¹¡ì„ ìµœì†Œí™”ë¥¼ ìœ„í•¨
 */
WINDOW *game_win = NULL;
WINDOW *ui_win = NULL;
static int last_score = -1;
static int last_opponent_score = -1;
static int imu_fd_global = -1;

// ìƒ‰ìƒ ì´ˆê¸°í™” í•¨ìˆ˜
void init_game_colors() {
    if (has_colors()) {
        start_color();
        
        // ìƒ‰ìƒ ìŒ ì •ì˜
        init_pair(COLOR_PLAYER, COLOR_CYAN, COLOR_BLACK);      // í”Œë ˆì´ì–´: ì²­ë¡ìƒ‰
        init_pair(COLOR_BULLET, COLOR_YELLOW, COLOR_BLACK);    // ì´ì•Œ: ë…¸ë€ìƒ‰
        init_pair(COLOR_OBSTACLE, COLOR_RED, COLOR_BLACK);     // ì¥ì• ë¬¼: ë¹¨ê°„ìƒ‰
        init_pair(COLOR_LIFE, COLOR_RED, COLOR_BLACK);         // ë¼ì´í”„: ë¹¨ê°„ìƒ‰
        init_pair(COLOR_BORDER, COLOR_WHITE, COLOR_BLACK);     // í…Œë‘ë¦¬: í°ìƒ‰
        init_pair(COLOR_UI, COLOR_GREEN, COLOR_BLACK);         // UI: ì´ˆë¡ìƒ‰
        init_pair(COLOR_SCORE, COLOR_MAGENTA, COLOR_BLACK);    // ì ìˆ˜: ë§ˆì  íƒ€ìƒ‰
        init_pair(COLOR_ENEMY, COLOR_BLUE, COLOR_BLACK);       // ì  ì ìˆ˜: íŒŒë€ìƒ‰
    }
}

int get_opponent_score() {
    int score;
    pthread_mutex_lock(&network_mutex);
    score = opponent_score;
    pthread_mutex_unlock(&network_mutex);
    return score;
}

int debug_init_controller=0;
void init_controller(){
    imu_fd_global = init_adxl345();
    if (imu_fd_global >= 0) {
        create_thread(&imu_thread, imu_thread_func, &imu_fd_global);
    }
    debug_init_controller=1;
}

void init_game() {
    initscr();
    clear();
    refresh();

    noecho();
    curs_set(FALSE);
    timeout(0);
    keypad(stdscr, TRUE);
    
    // ìƒ‰ìƒ ì´ˆê¸°í™”
    init_game_colors();
    
    srand(seed);
    //ë””ë²„ê¹…
    printf("[client] seed: %d\n", seed);
    
    //ê¸°ì¡´ ìœˆë„ìš° ìˆìœ¼ë©´ ì‚­ì œ
    if(game_win){
        delwin(game_win);
        game_win = NULL;
    }
    if(ui_win){
        delwin(ui_win);
        ui_win = NULL;
    }

    erase();
    refresh();

    //ë”ë¸” ë²„í¼ë§ ìœˆë„ìš°
    game_win = newwin(HEIGHT, WIDTH, 0, 0);
    ui_win = newwin(HEIGHT, 35, 0, WIDTH + 2);

    nodelay(game_win, TRUE);
    nodelay(ui_win, TRUE);
    keypad(game_win, TRUE);

    //ìœˆë„ìš° ì´ˆê¸°í™”
    werase(game_win);
    werase(ui_win);
    wrefresh(game_win);
    wrefresh(ui_win);

    player_x = WIDTH / 2;
    player_y = HEIGHT - 2;

    //ë°œì‚¬ì²´ì™€ ì¥ì• ë¬¼ ì´ˆê¸°í™”
    for (int i = 0; i < MAX_BULLETS; i++) {
        bullets[i].active = 0;
    }
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        obstacles[i].active = 0;
    }
    for (int i = 0; i < MAX_ITEMS; i++) {
        items[i].active = 0;
    }
    effect_timer = 0;
    effect_type = -1;
    int rows, cols;
    getmaxyx(stdscr, rows, cols);
    if (rows < HEIGHT + 2 || cols < WIDTH + 35) {
        endwin();
        printf("í„°ë¯¸ë„ ì°½ í¬ê¸°ê°€ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤.\n");
        printf("ìµœì†Œ %dí–‰ x %dì—´ ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤.\n", HEIGHT + 2, WIDTH + 35);
        exit(1);
    }

    refresh();
}
// ì•„ì´í…œ ìƒì„± í•¨ìˆ˜
void spawn_item() {
    for (int i = 0; i < MAX_ITEMS; i++) {
        if (!items[i].active) {
            items[i].active = 1;
            items[i].x = rand() % (WIDTH - 2) + 1;
            items[i].y = 1;
            items[i].type = rand() % 2; // 0: Clear All, 1: Bomb
            break;
        }
    }
}
void end_game() {
    if (game_win) {
        delwin(game_win);
        game_win = NULL;
    }
    if (ui_win) {
        delwin(ui_win);
        ui_win = NULL;
    }

    if(current_game_mode == GAME_MODE_SINGLE){
        clear();
        wattron(stdscr, COLOR_PAIR(COLOR_SCORE));
        mvprintw(5, 10, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        mvprintw(6, 10, "â•‘      ê²Œì„ ê²°ê³¼           â•‘");
        mvprintw(7, 10, "â•‘                          â•‘");
        mvprintw(8, 10, "â•‘   ë‹¹ì‹ ì˜ ì ìˆ˜: %-9d â•‘", score);
        mvprintw(9, 10, "â•‘                          â•‘");
        mvprintw(10,10, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        wattroff(stdscr, COLOR_PAIR(COLOR_SCORE));
        refresh();
        usleep(5000000);
    }
    
    //ê²Œì„ ì¢…ë£Œì‹œ ìŠ¤ë ˆë“œ ì¢…ë£Œì¡°ê±´ì¸ is_running = 0
    extern volatile int is_running;
    is_running = 0;
    printf("\nGame Over! Score: %d\n", score);
}
// ì•„ì´í…œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
void update_items(int frame) {
    for (int i = 0; i < MAX_ITEMS; i++) {
        if (items[i].active) {
            if (frame % 2 == 0) {
                items[i].y++;
            }
            if (items[i].y >= HEIGHT - 1) {
                items[i].active = 0;
            }
        }
    }
}

// ì•„ì´í…œ ì¶©ëŒ ì²´í¬ ë° íš¨ê³¼ ì ìš© í•¨ìˆ˜
void check_item_collisions() {
    for (int i = 0; i < MAX_ITEMS; i++) {
        if (items[i].active && items[i].x == player_x && items[i].y == player_y) {
            items[i].active = 0;
            effect_type = items[i].type;
            effect_timer = 30; // ì´í™íŠ¸ í‘œì‹œ ì‹œê°„
            switch (items[i].type) {
                case 0: // Clear All
                    for (int j = 0; j < MAX_OBSTACLES; j++) {
                        obstacles[j].active = 0;
                    }
                    break;
                case 1: // Bomb
                    for (int j = 0; j < MAX_OBSTACLES; j++) {
                        if (obstacles[j].active &&
                            abs(obstacles[j].x - player_x) <= 1 &&
                            abs(obstacles[j].y - player_y) <= 1) {
                            obstacles[j].active = 0;
                        }
                    }
                    break;
            }
        }
    }
}

// ì´í™íŠ¸ ê·¸ë¦¬ê¸° í•¨ìˆ˜
void draw_effects() {
    if (effect_timer > 0) {
        if (effect_type == 0) { // Clear All
            wattron(game_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
            mvwprintw(game_win, HEIGHT / 2, WIDTH / 2 - 3, "BOOM!");
            wattroff(game_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        } else if (effect_type == 1) { // Bomb
            wattron(game_win, COLOR_PAIR(COLOR_BULLET) | A_BOLD);
            for (int dy = -1; dy <= 1; dy++) {
                for (int dx = -1; dx <= 1; dx++) {
                    int ex = player_x + dx;
                    int ey = player_y + dy;
                    if (ex >= 1 && ex < WIDTH - 1 && ey >= 1 && ey < HEIGHT - 1) {
                        mvwprintw(game_win, ey, ex, "*");
                    }
                }
            }
            wattroff(game_win, COLOR_PAIR(COLOR_BULLET) | A_BOLD);
        }
    }
}
// ëŒ€ê¸° í™”ë©´ ê·¸ë¦¬ê¸° (í–¥ìƒëœ ë²„ì „)
void draw_waiting_screen() {
    werase(game_win);
    
    // í™”ë ¤í•œ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
    wattron(game_win, COLOR_PAIR(COLOR_BORDER));
    for (int i = 0; i < WIDTH; i++) {
        mvwprintw(game_win, 0, i, "â•");
        mvwprintw(game_win, HEIGHT - 1, i, "â•");
    }
    for (int i = 0; i < HEIGHT; i++) {
        mvwprintw(game_win, i, 0, "â•‘");
        mvwprintw(game_win, i, WIDTH - 1, "â•‘");
    }
    // ëª¨ì„œë¦¬
    mvwprintw(game_win, 0, 0, "â•”");
    mvwprintw(game_win, 0, WIDTH - 1, "â•—");
    mvwprintw(game_win, HEIGHT - 1, 0, "â•š");
    mvwprintw(game_win, HEIGHT - 1, WIDTH - 1, "â•");
    wattroff(game_win, COLOR_PAIR(COLOR_BORDER));
    
    // ëŒ€ê¸° ë©”ì‹œì§€ ë°•ìŠ¤
    int box_width = 42;
    int box_height = 10;
    int start_x = (WIDTH - box_width) / 2;
    int start_y = (HEIGHT - box_height) / 2;
    
    // ë°•ìŠ¤ í…Œë‘ë¦¬ (ìƒ‰ìƒ ì ìš©)
    wattron(game_win, COLOR_PAIR(COLOR_UI));
    for (int i = 0; i < box_width; i++) {
        mvwprintw(game_win, start_y, start_x + i, "â•");
        mvwprintw(game_win, start_y + box_height - 1, start_x + i, "â•");
    }
    for (int i = 0; i < box_height; i++) {
        mvwprintw(game_win, start_y + i, start_x, "â•‘");
        mvwprintw(game_win, start_y + i, start_x + box_width - 1, "â•‘");
    }
    mvwprintw(game_win, start_y, start_x, "â•”");
    mvwprintw(game_win, start_y, start_x + box_width - 1, "â•—");
    mvwprintw(game_win, start_y + box_height - 1, start_x, "â•š");
    mvwprintw(game_win, start_y + box_height - 1, start_x + box_width - 1, "â•");
    
    // ë©”ì‹œì§€ ë‚´ìš©
    wattron(game_win, A_BOLD);
    mvwprintw(game_win, start_y + 2, start_x + 2, "ğŸ® ê²Œì„ ì¢…ë£Œ!");
    wattroff(game_win, A_BOLD);
    
    wattron(game_win, COLOR_PAIR(COLOR_SCORE));
    mvwprintw(game_win, start_y + 3, start_x + 2, "ğŸ’« ë‹¹ì‹ ì˜ ì ìˆ˜: %d", score);
    wattroff(game_win, COLOR_PAIR(COLOR_SCORE));
    
    wattron(game_win, COLOR_PAIR(COLOR_ENEMY));
    mvwprintw(game_win, start_y + 4, start_x + 2, "âš”ï¸  ìƒëŒ€ë°© ì ìˆ˜: %d", get_opponent_score());
    wattroff(game_win, COLOR_PAIR(COLOR_ENEMY));
    
    mvwprintw(game_win, start_y + 6, start_x + 2, "â³ ìƒëŒ€ë°©ì´ ê²Œì„ì„ ëë‚¼ ë•Œê¹Œì§€ ëŒ€ê¸° ì¤‘");
    wattroff(game_win, COLOR_PAIR(COLOR_UI));
    
    // ì• ë‹ˆë©”ì´ì…˜ìš© ì ë“¤
    static int dot_count = 0;
    dot_count = (dot_count + 1) % 4;
    wattron(game_win, COLOR_PAIR(COLOR_UI));
    for (int i = 0; i < dot_count; i++) {
        wprintw(game_win, ".");
    }
    wattroff(game_win, COLOR_PAIR(COLOR_UI));
}

// ê²Œì„ ì˜ì—­ë§Œ ê·¸ë¦¬ê¸° (ìƒ‰ìƒ ì ìš©ëœ ë²„ì „)
void draw_game_area() {
    // ëŒ€ê¸° ì¤‘ì´ë©´ ëŒ€ê¸° í™”ë©´ ê·¸ë¦¬ê¸°
    if (waiting_for_opponent) {
        draw_waiting_screen();
        return;
    }

    // ê²Œì„ ìœˆë„ìš° í´ë¦¬ì–´
    werase(game_win);
    
    // í™”ë ¤í•œ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
    wattron(game_win, COLOR_PAIR(COLOR_BORDER));
    for (int i = 0; i < WIDTH; i++) {
        mvwprintw(game_win, 0, i, "â•");
        mvwprintw(game_win, HEIGHT - 1, i, "â•");
    }
    for (int i = 0; i < HEIGHT; i++) {
        mvwprintw(game_win, i, 0, "â•‘");
        mvwprintw(game_win, i, WIDTH - 1, "â•‘");
    }
    // ëª¨ì„œë¦¬
    mvwprintw(game_win, 0, 0, "â•”");
    mvwprintw(game_win, 0, WIDTH - 1, "â•—");
    mvwprintw(game_win, HEIGHT - 1, 0, "â•š");
    mvwprintw(game_win, HEIGHT - 1, WIDTH - 1, "â•");
    wattroff(game_win, COLOR_PAIR(COLOR_BORDER));
    
    // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸° (ì²­ë¡ìƒ‰ ìš°ì£¼ì„ )
    wattron(game_win, COLOR_PAIR(COLOR_PLAYER) | A_BOLD);
    mvwprintw(game_win, player_y, player_x, "â–²");
    wattroff(game_win, COLOR_PAIR(COLOR_PLAYER) | A_BOLD);
    
    // ë°œì‚¬ì²´ ê·¸ë¦¬ê¸° (ë…¸ë€ìƒ‰ ì´ì•Œ)
    wattron(game_win, COLOR_PAIR(COLOR_BULLET) | A_BOLD);
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (bullets[i].active)
            mvwprintw(game_win, bullets[i].y, bullets[i].x, "â”‚");
    }
    wattroff(game_win, COLOR_PAIR(COLOR_BULLET) | A_BOLD);
    
    // ì¥ì• ë¬¼ ê·¸ë¦¬ê¸° (ë¹¨ê°„ìƒ‰ ì )
    wattron(game_win, COLOR_PAIR(COLOR_OBSTACLE) | A_BOLD);
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        if (obstacles[i].active)
            mvwprintw(game_win, obstacles[i].y, obstacles[i].x, "â—");
    }
    wattroff(game_win, COLOR_PAIR(COLOR_OBSTACLE) | A_BOLD);
    // ì•„ì´í…œ ê·¸ë¦¬ê¸°
    for (int i = 0; i < MAX_ITEMS; i++) {
        if (items[i].active) {
            wattron(game_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
            switch (items[i].type) {
                case 0: // Clear All
                    mvwprintw(game_win, items[i].y, items[i].x, "C");
                    break;
                case 1: // Bomb
                    mvwprintw(game_win, items[i].y, items[i].x, "B");
                    break;
            }
            wattroff(game_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        }
    }
    // ë¼ì´í”„ í‘œì‹œ (ë¹¨ê°„ìƒ‰ í•˜íŠ¸)
    wattron(game_win, COLOR_PAIR(COLOR_LIFE) | A_BOLD);
    mvwprintw(game_win, 1, WIDTH - 18, "Life: ");
    for (int i = 0; i < life; i++) {
        wprintw(game_win, "â™¥");
    }
    wattroff(game_win, COLOR_PAIR(COLOR_LIFE) | A_BOLD);
}

// UI ì˜ì—­ë§Œ ê·¸ë¦¬ê¸° (í–¥ìƒëœ ë²„ì „)
void draw_ui_area() {
    int current_score;
    int current_opponent_score;
    pthread_mutex_lock(&score_mutex);
    current_score = score;
    pthread_mutex_unlock(&score_mutex);
    
    pthread_mutex_lock(&network_mutex);
    current_opponent_score = opponent_score;
    pthread_mutex_unlock(&network_mutex);

    // ì ìˆ˜ê°€ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ UI ì—…ë°ì´íŠ¸
    if (current_score != last_score || current_opponent_score != last_opponent_score) {
        werase(ui_win);
        
        // UI í…Œë‘ë¦¬
        wattron(ui_win, COLOR_PAIR(COLOR_BORDER));
        for (int i = 0; i < 33; i++) {
            mvwprintw(ui_win, 0, i, "â•");
        }
        mvwprintw(ui_win, 0, 0, "â•”");
        mvwprintw(ui_win, 0, 32, "â•—");
        for (int i = 1; i < HEIGHT - 1; i++) {
            mvwprintw(ui_win, i, 0, "â•‘");
            mvwprintw(ui_win, i, 32, "â•‘");
        }
        for (int i = 0; i < 33; i++) {
            mvwprintw(ui_win, HEIGHT - 1, i, "â•");
        }
        mvwprintw(ui_win, HEIGHT - 1, 0, "â•š");
        mvwprintw(ui_win, HEIGHT - 1, 32, "â•");
        wattroff(ui_win, COLOR_PAIR(COLOR_BORDER));
        
        //ê²Œì„ëª¨ë“œì— ë”°ë¼ í‘œì‹œ
        wattron(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        if (current_game_mode == GAME_MODE_SINGLE) {
            mvwprintw(ui_win, 1, 2, "ğŸ¯ == 1ì¸ ëª¨ë“œ ==");
        } else {
            mvwprintw(ui_win, 1, 2, "ğŸ® == 2ì¸ ëª¨ë“œ ==");
            wattron(ui_win, COLOR_PAIR(COLOR_SCORE));
            mvwprintw(ui_win, 2, 2, "Seed: %d", seed);
            wattroff(ui_win, COLOR_PAIR(COLOR_SCORE));
        }
        wattroff(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);

        wattron(ui_win, COLOR_PAIR(COLOR_PLAYER) | A_BOLD);
        mvwprintw(ui_win, 3, 2, "ğŸš€ SPACE ESCAPE ğŸš€");
        wattroff(ui_win, COLOR_PAIR(COLOR_PLAYER) | A_BOLD);

        // ê²Œì„ ìƒíƒœ ì •ë³´
        wattron(ui_win, COLOR_PAIR(COLOR_LIFE) | A_BOLD);
        mvwprintw(ui_win, 5, 2, "â™¥ Life: %d", life);
        wattroff(ui_win, COLOR_PAIR(COLOR_LIFE) | A_BOLD);
        
        wattron(ui_win, COLOR_PAIR(COLOR_SCORE) | A_BOLD);
        mvwprintw(ui_win, 6, 2, "ğŸ’« Score: %d", current_score);
        wattroff(ui_win, COLOR_PAIR(COLOR_SCORE) | A_BOLD);
        
        wattron(ui_win, COLOR_PAIR(COLOR_BULLET));
        mvwprintw(ui_win, 7, 2, "ğŸ¯ Bullet: %d", MAX_BULLETS);
        wattroff(ui_win, COLOR_PAIR(COLOR_BULLET));
        
        wattron(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        mvwprintw(ui_win, 8, 2, "â­ LEVEL: %d", level);
        wattroff(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);

        // ì»¨íŠ¸ë¡¤ ê°€ì´ë“œ (IMU ì»¨íŠ¸ë¡¤ëŸ¬ ê¸°ë°˜)
        wattron(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        mvwprintw(ui_win, 10, 2, "ğŸ® [ Controls ]");
        wattroff(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        
        wattron(ui_win, COLOR_PAIR(COLOR_PLAYER));
        mvwprintw(ui_win, 11, 2, "Move: IMU Sensor");
        mvwprintw(ui_win, 12, 2, "      â†– â†‘ â†—");
        mvwprintw(ui_win, 13, 2, "      â† â— â†’");
        mvwprintw(ui_win, 14, 2, "      â†™ â†“ â†˜");
        mvwprintw(ui_win, 15, 2, "Shoot: Button Press");
        mvwprintw(ui_win, 16, 2, "Pause: [p] or Ctrl+Z");
        mvwprintw(ui_win, 17, 2, "Exit:  Ctrl+C");
        wattroff(ui_win, COLOR_PAIR(COLOR_PLAYER));
        
        //2ì¸ ëª¨ë“œì¼ ë•Œ ì¶”ê°€ ì •ë³´ í‘œì‹œ
        if (current_game_mode == GAME_MODE_MULTI) {
            wattron(ui_win, COLOR_PAIR(COLOR_ENEMY) | A_BOLD);
            mvwprintw(ui_win, 19, 2, "âš”ï¸ Opponent: %d", current_opponent_score);
            wattroff(ui_win, COLOR_PAIR(COLOR_ENEMY) | A_BOLD);
        }

        if (waiting_for_opponent) {
            wattron(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
            mvwprintw(ui_win, 21, 2, "â³ Status: Waiting...");
            wattroff(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        }
        
        // ë””ë²„ê·¸ ì •ë³´
        wattron(ui_win, COLOR_PAIR(COLOR_UI));
        mvwprintw(ui_win, 24, 2, "Controller: %s", debug_init_controller ? "âœ“" : "âœ—");
        mvwprintw(ui_win, 25, 2, "Direction: %c", imu_direction[0]);
        wattroff(ui_win, COLOR_PAIR(COLOR_UI));

        last_score = current_score;
        last_opponent_score = current_opponent_score;
    }
}

//ì¥ì• ë¬¼ ìƒì„± -> LEVELì´ ì¦ê°€í• ìˆ˜ë¡ ë¹ ë¥´ê²Œ ìƒì„±ë˜ê±°ë‚˜ ë‚´ë ¤ì˜¤ë„ë¡
void spawn_obstacle() {
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        if (!obstacles[i].active) {
            obstacles[i].active = 1;
            obstacles[i].x = rand() % (WIDTH - 22) + 1;
            obstacles[i].y = 1;
            break;
        }
    }
}

void update_bullets() {
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (bullets[i].active) {
            bullets[i].y--;
            if (bullets[i].y <= 0)
                bullets[i].active = 0;
        }
    }
}

void update_obstacles() {
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        if (obstacles[i].active) {
            obstacles[i].y++;
            if (obstacles[i].y >= HEIGHT - 2) {
                life--;
                obstacles[i].active = 0;
                if (life <= 0){
                    game_over = 1;
                    if(current_game_mode == GAME_MODE_SINGLE){
                        extern volatile int game_result_received;
                        game_result_received = 1;
                    }
                } 
            }
        }
    }
}

//mutexì‚¬ìš©, scoreë³´í˜¸
void check_collisions() {
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        if (!obstacles[i].active) continue;
        for (int j = 0; j < MAX_BULLETS; j++) {
            if (bullets[j].active &&
                bullets[j].x == obstacles[i].x &&
                bullets[j].y == obstacles[i].y) {
                bullets[j].active = 0;
                obstacles[i].active = 0;
                pthread_mutex_lock(&score_mutex);
                score += 10;
                pthread_mutex_unlock(&score_mutex);
                break;
            }
        }
    }
}

void handle_input() {
    pthread_mutex_lock(&imu_lock);
    char ch = imu_direction[0];
    pthread_mutex_unlock(&imu_lock);

    pthread_mutex_lock(&switch_lock);
    char ch2 = imu_direction[1];
    char ch3 = imu_direction[2];
    pthread_mutex_unlock(&switch_lock);
    
    //ëŒ€ê¸° ì¤‘ì´ë©´ ì…ë ¥ ë¬´ì‹œ
    if (waiting_for_opponent) {
        wgetch(game_win); // ì…ë ¥ ë²„í¼ ë¹„ìš°ê¸°
        return;
    }
    if (ch == ERR) return;  // ì…ë ¥ì´ ì—†ìœ¼ë©´ ë°”ë¡œ ë¦¬í„´

    switch (ch) {
        case '7':  // â†–
            if (player_x > 1) player_x--;
            if (player_y > 1) player_y--;
            break;
        case '8':  // â†‘
            if (player_y > 1) player_y--;
            break;
        case '9':  // â†—
            if (player_x < WIDTH - 2) player_x++;
            if (player_y > 1) player_y--;
            break;
        case '4':  // â†
            if (player_x > 1) player_x--;
            break;
        case '5':  // ì •ì§€ (ì‚¬ìš© X)
            break;
        case '6':  // â†’
            if (player_x < WIDTH - 2) player_x++;
            break;
        case '1':  // â†™
            if (player_x > 1) player_x--;
            if (player_y < HEIGHT - 2) player_y++;
            break;
        case '2':  // â†“
            if (player_y < HEIGHT - 2) player_y++;
            break;
        case '3':  // â†˜
            if (player_x < WIDTH - 2) player_x++;
            if (player_y < HEIGHT - 2) player_y++;
            break;
        case ' ':
            for (int i = 0; i < MAX_BULLETS; i++) {
                if (!bullets[i].active) {
                    bullets[i].active = 1;
                    bullets[i].x = player_x;
                    bullets[i].y = player_y - 1;
                    break;
                }
            }
            break;
        case 'p':
            paused = !paused;
            break;
        default:
            break;
    }
    
    switch(ch2){
        case '1':
            for (int i = 0; i < MAX_BULLETS; i++) {
                if (!bullets[i].active) {
                    bullets[i].active = 1;
                    bullets[i].x = player_x;
                    bullets[i].y = player_y - 1;
                    break;
                }
            }
            break;
    }
    
    switch(ch3) {
        case '1':
            if (has_item != -1) { // Check if player has an item
                switch (has_item) {
                    case 0: // Clear All item
                        for (int j = 0; j < MAX_OBSTACLES; j++) {
                            obstacles[j].active = 0; // Remove all obstacles
                        }
                        effect_type = 0; // Set effect for "Clear All"
                        effect_timer = 30; // Display effect for 30 frames
                        break;
                    case 1: // Bomb item
                        for (int j = 0; j < MAX_OBSTACLES; j++) {
                            if (obstacles[j].active &&
                                abs(obstacles[j].x - player_x) <= 1 &&
                                abs(obstacles[j].y - player_y) <= 1) {
                                obstacles[j].active = 0; // Remove nearby obstacles
                            }
                        }
                        effect_type = 1; // Set effect for "Bomb"
                        effect_timer = 30; // Display effect for 30 frames
                        break;
                }
                has_item = -1; // Reset item after use
            }
            break;
    }
}

// run_game() í•¨ìˆ˜ëŠ” ìŠ¤ë ˆë“œì—ì„œ í˜¸ì¶œë˜ì–´ ê²Œì„ ë£¨í”„ ì „ì²´ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
void* run_game(void* arg) {
    (void)arg;
    setlocale(LC_ALL, "");

    // ê²Œì„ ì´ˆê¸°í™”
    init_game();
    init_controller();
    int frame = 0;
    
    // ê²Œì„ ë£¨í”„ (ë£¨í”„ í•œë²ˆ ëŒë•Œë§ˆë‹¤ frameì´ ì¦ê°€í•¨.)
    extern volatile int game_result_received;

    while (!game_result_received) { //network.cì˜ handle_game_resultê¹Œì§€ (ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ê°€ ëë‚˜ì•¼ë§Œ í˜¸ì¶œë¨)
        if (!paused) {
            //ë Œë”ë§ ë®¤í…ìŠ¤ë¡œ ë³´í˜¸
            pthread_mutex_lock(&render_mutex);

            //ê²Œì„ì´ ëë‚¬ì§€ë§Œ ì•„ì§ ê²°ê³¼ë¥¼ ë°›ì§€ ëª»í•œ ê²½ìš°
            if (game_over && current_game_mode == GAME_MODE_MULTI && !waiting_for_opponent) {
                waiting_for_opponent = 1;  //ëŒ€ê¸° ìƒíƒœë¡œ ì „í™˜
            }
            //ëŒ€ê¸° ì¤‘ì´ ì•„ë‹ë• ë™ì‘ì œì–´ê°€ëŠ¥
            if (!waiting_for_opponent) {
                handle_input();
                update_bullets();
                
                if (frame % obstacle_interval == 0) update_obstacles();
                if (frame % spawn_interval == 0) spawn_obstacle();
                if (frame % item_spawn_interval == 0) spawn_item();
                update_items(frame);
                check_collisions();
                check_item_collisions();
                if (effect_timer > 0) {
                    effect_timer--;
                    if (effect_timer == 0) {
                        effect_type = -1;
                    }
                }
                frame++;
                
                // ë ˆë²¨ì—… ì¡°ê±´
                if (frame % 500 == 0) {
                    level++;
                    obstacle_interval = (obstacle_interval > 5) ? obstacle_interval - 2 : 5;
                    spawn_interval = (spawn_interval > 3) ? spawn_interval - 1 : 3;
                }
            } else {
                // ëŒ€ê¸° ì¤‘ì—ë„ ì…ë ¥ì€ ì²˜ë¦¬ (ë²„í¼ ë¹„ìš°ê¸° ìœ„í•´)
                handle_input();
            }

            // í™”ë©´ ê·¸ë¦¬ê¸° (ëŒ€ê¸° ì¤‘ì´ë“  ì•„ë‹ˆë“ )
            draw_game_area();
            draw_ui_area();

            // ìœˆë„ìš° ìƒˆë¡œê³ ì¹¨
            wnoutrefresh(game_win);
            wnoutrefresh(ui_win);
            doupdate();

            pthread_mutex_unlock(&render_mutex);
        } else {
            pthread_mutex_lock(&render_mutex);
            
            // ì¼ì‹œì •ì§€ í™”ë©´ì„ ë” ì˜ˆì˜ê²Œ í‘œì‹œ
            int pause_x = WIDTH / 2 - 10;
            int pause_y = HEIGHT / 2 - 3;
            
            wattron(game_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
            mvwprintw(game_win, pause_y, pause_x, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            mvwprintw(game_win, pause_y + 1, pause_x, "â•‘                  â•‘");
            mvwprintw(game_win, pause_y + 2, pause_x, "â•‘   â¸ï¸  PAUSED    â•‘");
            mvwprintw(game_win, pause_y + 3, pause_x, "â•‘                  â•‘");
            mvwprintw(game_win, pause_y + 4, pause_x, "â•‘  Press 'p' to    â•‘");
            mvwprintw(game_win, pause_y + 5, pause_x, "â•‘    continue      â•‘");
            mvwprintw(game_win, pause_y + 6, pause_x, "â•‘                  â•‘");
            mvwprintw(game_win, pause_y + 7, pause_x, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            wattroff(game_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
            
            wnoutrefresh(game_win);
            doupdate();
            pthread_mutex_unlock(&render_mutex);
        }
        usleep(30000);
    }
    
    end_game();
    join_thread(imu_thread);
    return NULL;
}
