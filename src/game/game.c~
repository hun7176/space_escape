#include <ncurses.h>
#include <stdlib.h>
#include <time.h>
#include <locale.h>
#include <signal.h>
#include <unistd.h>
#include "game.h"
#include "game_parameter.h"   // WIDTH, HEIGHT, MAX_BULLETS, MAX_OBSTACLES ë“± ì •ì˜
#include "intro_ui.h"          // init_colors(), show_main_menu(), func_pause(), end_by_signal(), ë“±
#include "common.h"
#include "controller.h"
pthread_mutex_t score_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t render_mutex = PTHREAD_MUTEX_INITIALIZER;  // ë Œë”ë§ ë³´í˜¸ìš© ë®¤í…ìŠ¤

//ì»¨íŠ¸ë¡¤ëŸ¬ìš©
char imu_direction[3] = {'5', '0', '0'};
pthread_mutex_t switch_lock;  
pthread_mutex_t imu_lock = PTHREAD_MUTEX_INITIALIZER;
pthread_t imu_thread;

// ìƒ‰ìƒ ì •ì˜
#define COLOR_PLAYER    1
#define COLOR_BULLET    2
#define COLOR_OBSTACLE  3
#define COLOR_LIFE      4
#define COLOR_BORDER    5
#define COLOR_UI        6
#define COLOR_SCORE     7
#define COLOR_ENEMY     8
#define COLOR_ITEM      9   // ì•„ì´í…œ ìƒ‰ìƒ ì¶”ê°€
#define COLOR_BOMB      10  // í­íƒ„ ìƒ‰ìƒ ì¶”ê°€

// ì•„ì´í…œ íƒ€ì… ì •ì˜
#define ITEM_TYPE_CLEAR_MAP 1
#define ITEM_TYPE_BOMB      2
#define MAX_ITEMS           10

// ì•„ì´í…œ êµ¬ì¡°ì²´
typedef struct {
    int x, y;
    int active;
    int type;  // ITEM_TYPE_CLEAR_MAP ë˜ëŠ” ITEM_TYPE_BOMB
} Item;

// í­íƒ„ ì´í™íŠ¸ êµ¬ì¡°ì²´
typedef struct {
    int x, y;
    int active;
    int duration;  // ì´í™íŠ¸ ì§€ì† ì‹œê°„
    int radius;    // í­ë°œ ë°˜ê²½
} BombEffect;

extern int seed; //networkë¡œ ë¶€ì—¬ë°›ì€ seed

// ì „ì—­ ê²Œì„ ë³€ìˆ˜ë“¤
int player_x, player_y;           // í”Œë ˆì´ì–´ ìœ„ì¹˜
int life = 3;                     // ë‚¨ì€ ëª©ìˆ¨
int score = 0;                    // ì ìˆ˜
int game_over = 0;                // ê²Œì„ ì¢…ë£Œ í”Œë˜ê·¸
int paused = 0;                   // ì¼ì‹œì •ì§€ í”Œë˜ê·¸
int current_key = -1;             // ì…ë ¥ í‚¤ ì €ì¥ (ë¯¸ì‚¬ìš©)
Bullet bullets[MAX_BULLETS];      // ë°œì‚¬ì²´ ë°°ì—´
Obstacle obstacles[MAX_OBSTACLES];// ì¥ì• ë¬¼ ë°°ì—´
Item items[MAX_ITEMS];            // ì•„ì´í…œ ë°°ì—´ ì¶”ê°€
BombEffect bomb_effects[5];       // í­íƒ„ ì´í™íŠ¸ ë°°ì—´ (ìµœëŒ€ 5ê°œ)

// ì•„ì´í…œ ê´€ë ¨ ë³€ìˆ˜
int has_bomb = 0;                 // í­íƒ„ ë³´ìœ  ì—¬ë¶€
int item_spawn_chance = 50;      // ì•„ì´í…œ ìƒì„± í™•ë¥  (ë‚®ì„ìˆ˜ë¡ ìì£¼ ìƒì„±)

//ê²Œì„ ë‚œì´ë„ ì¡°ì •ì„ ìœ„í•œ ë³€ìˆ˜ë“¤
int level = 1;                     // í˜„ì¬ ë ˆë²¨
int obstacle_interval = 20;        // ì¥ì• ë¬¼ ì´ë™ ì£¼ê¸° (í”„ë ˆì„ ë‹¨ìœ„)
int spawn_interval    = 10;        // ì¥ì• ë¬¼ ìƒì„± ì£¼ê¸° (í”„ë ˆì„ ë‹¨ìœ„)

// ê²Œì„ ëŒ€ê¸° ìƒíƒœ ë³€ìˆ˜ ì¶”ê°€
int waiting_for_opponent = 0;     // ìƒëŒ€ë°© ì¢…ë£Œ ëŒ€ê¸° ì¤‘ì¸ì§€ í‘œì‹œ

//ë”ë¸” ë²„í¼ë§ì„ ìœ„í•œ ë³€ìˆ˜ë“¤
/**
 * game_win, un_winìœ¼ë¡œ í™”ë©´ì„ ë¶„ë¦¬í•˜ì—¬ ê°ê° ë…ë¦½ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸
 * ê¹œë¹¡ì„ ìµœì†Œí™”ë¥¼ ìœ„í•¨
 */
WINDOW *game_win = NULL;
WINDOW *ui_win = NULL;
static int last_score = -1;
static int last_opponent_score = -1;
static int imu_fd_global = -1;

int debug_init_controller = 0;
int controller_available = 0; // ì»¨íŠ¸ë¡¤ëŸ¬ ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€

// ìƒ‰ìƒ ì´ˆê¸°í™” í•¨ìˆ˜
void init_game_colors() {
    if (has_colors()) {
        start_color();
        init_pair(COLOR_PLAYER, COLOR_CYAN, COLOR_BLACK);      // í”Œë ˆì´ì–´: ì²­ë¡ìƒ‰
        init_pair(COLOR_BULLET, COLOR_YELLOW, COLOR_BLACK);    // ì´ì•Œ: ë…¸ë€ìƒ‰
        init_pair(COLOR_OBSTACLE, COLOR_RED, COLOR_BLACK);     // ì¥ì• ë¬¼: ë¹¨ê°„ìƒ‰
        init_pair(COLOR_LIFE, COLOR_RED, COLOR_BLACK);         // ë¼ì´í”„: ë¹¨ê°„ìƒ‰
        init_pair(COLOR_BORDER, COLOR_WHITE, COLOR_BLACK);     // í…Œë‘ë¦¬: í°ìƒ‰
        init_pair(COLOR_UI, COLOR_GREEN, COLOR_BLACK);         // UI: ì´ˆë¡ìƒ‰
        init_pair(COLOR_SCORE, COLOR_MAGENTA, COLOR_BLACK);    // ì ìˆ˜: ë§ˆì  íƒ€ìƒ‰
        init_pair(COLOR_ENEMY, COLOR_BLUE, COLOR_BLACK);       // ì  ì ìˆ˜: íŒŒë€ìƒ‰
        init_pair(COLOR_ITEM, COLOR_CYAN, COLOR_BLACK);        // ì•„ì´í…œ: ì²­ë¡ìƒ‰
        init_pair(COLOR_BOMB, COLOR_RED, COLOR_YELLOW);        // í­íƒ„: ë¹¨ê°„ìƒ‰ ë°°ê²½ ë…¸ë€ìƒ‰
    }
}

int get_opponent_score() {
    int score;
    pthread_mutex_lock(&network_mutex);
    score = opponent_score;
    pthread_mutex_unlock(&network_mutex);
    return score;
}

void init_controller(){
    imu_fd_global = init_adxl345();
    if (imu_fd_global >= 0) {
        create_thread(&imu_thread, imu_thread_func, &imu_fd_global);
        debug_init_controller = 1;
        controller_available = 1;
    }
    else{
        debug_init_controller = 0;
        controller_available = 0;
    }

}

void init_game() {
    
    initscr();
    clear();
    refresh();

    noecho();
    curs_set(FALSE);
    timeout(0);
    keypad(stdscr, TRUE);
    
    //ìƒ‰ìƒ ì´ˆê¸°í™”
    init_game_colors();
    
    srand(seed);
   
    
    //ê¸°ì¡´ ìœˆë„ìš° ìˆìœ¼ë©´ ì‚­ì œ
    if(game_win){
        delwin(game_win);
        game_win = NULL;
    }
    if(ui_win){
        delwin(ui_win);
        ui_win = NULL;
    }

    erase();
    refresh();

    //ë”ë¸” ë²„í¼ë§ ìœˆë„ìš°
    game_win = newwin(HEIGHT, WIDTH, 0, 0);
    ui_win = newwin(HEIGHT, 35, 0, WIDTH + 2);

    nodelay(game_win, TRUE);
    nodelay(ui_win, TRUE);
    keypad(game_win, TRUE);

    //ìœˆë„ìš° ì´ˆê¸°í™”
    werase(game_win);
    werase(ui_win);
    wrefresh(game_win);
    wrefresh(ui_win);

    player_x = WIDTH / 2;
    player_y = HEIGHT - 2;

    //ë°œì‚¬ì²´ì™€ ì¥ì• ë¬¼ ì´ˆê¸°í™”
    for (int i = 0; i < MAX_BULLETS; i++) {
        bullets[i].active = 0;
    }
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        obstacles[i].active = 0;
    }
    
    // ì•„ì´í…œ ì´ˆê¸°í™”
    for (int i = 0; i < MAX_ITEMS; i++) {
        items[i].active = 0;
    }
    
    // í­íƒ„ ì´í™íŠ¸ ì´ˆê¸°í™”
    for (int i = 0; i < 5; i++) {
        bomb_effects[i].active = 0;
    }
    
    int rows, cols;
    getmaxyx(stdscr, rows, cols);
    if (rows < HEIGHT + 2 || cols < WIDTH + 35) {
        endwin();
        printf("í„°ë¯¸ë„ ì°½ í¬ê¸°ê°€ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤.\n");
        printf("ìµœì†Œ %dí–‰ x %dì—´ ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤.\n", HEIGHT + 2, WIDTH + 35);
        exit(1);
    }

    refresh();
}

void end_game() {
    if (game_win) {
        delwin(game_win);
        game_win = NULL;
    }
    if (ui_win) {
        delwin(ui_win);
        ui_win = NULL;
    }

    if(current_game_mode == GAME_MODE_SINGLE){
        clear();
        wattron(stdscr, COLOR_PAIR(COLOR_SCORE));
        mvprintw(5, 10, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        mvprintw(6, 10, "â•‘      ê²Œì„ ê²°ê³¼           â•‘");
        mvprintw(7, 10, "â•‘                          â•‘");
        mvprintw(8, 10, "â•‘   ë‹¹ì‹ ì˜ ì ìˆ˜: %-9d â•‘", score);
        mvprintw(9, 10, "â•‘                          â•‘");
        mvprintw(10,10, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        wattroff(stdscr, COLOR_PAIR(COLOR_SCORE));
        refresh();
        usleep(5000000);
    }
    
    //ê²Œì„ ì¢…ë£Œì‹œ ìŠ¤ë ˆë“œ ì¢…ë£Œì¡°ê±´ì¸ is_running = 0
    extern volatile int is_running;
    is_running = 0;
    printf("\nGame Over! Score: %d\n", score);
}

// ì•„ì´í…œ ìƒì„± í•¨ìˆ˜
void spawn_item() {
    // í™•ë¥ ì ìœ¼ë¡œ ì•„ì´í…œ ìƒì„±
    if (rand() % item_spawn_chance != 0) return;
    
    for (int i = 0; i < MAX_ITEMS; i++) {
        if (!items[i].active) {
            items[i].active = 1;
            items[i].x = rand() % (WIDTH - 2) + 1;
            items[i].y = 1;
            // 60% í™•ë¥ ë¡œ ë§µ í´ë¦¬ì–´, 40% í™•ë¥ ë¡œ í­íƒ„
            items[i].type = (rand() % 10 < 6) ? ITEM_TYPE_CLEAR_MAP : ITEM_TYPE_BOMB;
            break;
        }
    }
}

// ì•„ì´í…œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
void update_items() {
    for (int i = 0; i < MAX_ITEMS; i++) {
        if (items[i].active) {
            items[i].y++;
            if (items[i].y >= HEIGHT - 1) {
                items[i].active = 0;
            }
        }
    }
}

void create_bomb_effect(int x, int y) {
    for (int i = 0; i < 5; i++) {
        if (!bomb_effects[i].active) {
            bomb_effects[i].active = 1;
            bomb_effects[i].x = x;
            bomb_effects[i].y = y;
            bomb_effects[i].duration = 15;  //15í”„ë ˆì„ ë™ì•ˆ ì§€ì†
            bomb_effects[i].radius = 12;    //ë°˜ê²½ì„ 12ë¡œ í¬ê²Œ ì¦ê°€
            break;
        }
    }
}

// í­íƒ„ ì´í™íŠ¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
void update_bomb_effects() {
    for (int i = 0; i < 5; i++) {
        if (bomb_effects[i].active) {
            bomb_effects[i].duration--;
            if (bomb_effects[i].duration <= 0) {
                bomb_effects[i].active = 0;
            }
        }
    }
}

// í­íƒ„ ì´í™íŠ¸ë¡œ ì¥ì• ë¬¼ íŒŒê´´ í•¨ìˆ˜ ìˆ˜ì •
void destroy_obstacles_in_bomb_range(int bomb_x, int bomb_y, int radius) {
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        if (obstacles[i].active) {
            int dx = abs(obstacles[i].x - bomb_x);
            int dy = abs(obstacles[i].y - bomb_y);
            
            // ë§¨í•˜íƒ„ ê±°ë¦¬ë¡œ ê³„ì‚°í•˜ê±°ë‚˜ ìœ í´ë¦¬ë“œ ê±°ë¦¬ë¡œ ê³„ì‚°
            // í˜„ì¬ëŠ” ì •ì‚¬ê°í˜• ë²”ìœ„ë¡œ ì²´í¬
            if (dx <= radius && dy <= radius) {
                obstacles[i].active = 0;
                pthread_mutex_lock(&score_mutex);
                score += 15;  // í­íƒ„ìœ¼ë¡œ íŒŒê´´ì‹œ ë³´ë„ˆìŠ¤ ì ìˆ˜
                pthread_mutex_unlock(&score_mutex);
            }
        }
    }
}

// ëŒ€ê¸° í™”ë©´ ê·¸ë¦¬ê¸° (í–¥ìƒëœ ë²„ì „)
void draw_waiting_screen() {
    werase(game_win);
    
    // í™”ë ¤í•œ í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
    wattron(game_win, COLOR_PAIR(COLOR_BORDER));
    for (int i = 0; i < WIDTH; i++) {
        mvwprintw(game_win, 0, i, "â•");
        mvwprintw(game_win, HEIGHT - 1, i, "â•");
    }
    for (int i = 0; i < HEIGHT; i++) {
        mvwprintw(game_win, i, 0, "â•‘");
        mvwprintw(game_win, i, WIDTH - 1, "â•‘");
    }
    // ëª¨ì„œë¦¬
    mvwprintw(game_win, 0, 0, "â•”");
    mvwprintw(game_win, 0, WIDTH - 1, "â•—");
    mvwprintw(game_win, HEIGHT - 1, 0, "â•š");
    mvwprintw(game_win, HEIGHT - 1, WIDTH - 1, "â•");
    wattroff(game_win, COLOR_PAIR(COLOR_BORDER));
    
    // ëŒ€ê¸° ë©”ì‹œì§€ ë°•ìŠ¤
    int box_width = 42;
    int box_height = 10;
    int start_x = (WIDTH - box_width) / 2;
    int start_y = (HEIGHT - box_height) / 2;
    
    // ë°•ìŠ¤ í…Œë‘ë¦¬ (ìƒ‰ìƒ ì ìš©)
    wattron(game_win, COLOR_PAIR(COLOR_UI));
    for (int i = 0; i < box_width; i++) {
        mvwprintw(game_win, start_y, start_x + i, "â•");
        mvwprintw(game_win, start_y + box_height - 1, start_x + i, "â•");
    }
    for (int i = 0; i < box_height; i++) {
        mvwprintw(game_win, start_y + i, start_x, "â•‘");
        mvwprintw(game_win, start_y + i, start_x + box_width - 1, "â•‘");
    }
    mvwprintw(game_win, start_y, start_x, "â•”");
    mvwprintw(game_win, start_y, start_x + box_width - 1, "â•—");
    mvwprintw(game_win, start_y + box_height - 1, start_x, "â•š");
    mvwprintw(game_win, start_y + box_height - 1, start_x + box_width - 1, "â•");
    
    // ë©”ì‹œì§€ ë‚´ìš©
    wattron(game_win, A_BOLD);
    mvwprintw(game_win, start_y + 2, start_x + 2, "ğŸ® ê²Œì„ ì¢…ë£Œ!");
    wattroff(game_win, A_BOLD);
    
    wattron(game_win, COLOR_PAIR(COLOR_SCORE));
    mvwprintw(game_win, start_y + 3, start_x + 2, "ğŸ’« ë‹¹ì‹ ì˜ ì ìˆ˜: %d", score);
    wattroff(game_win, COLOR_PAIR(COLOR_SCORE));
    
    wattron(game_win, COLOR_PAIR(COLOR_ENEMY));
    mvwprintw(game_win, start_y + 4, start_x + 2, "âš”ï¸  ìƒëŒ€ë°© ì ìˆ˜: %d", get_opponent_score());
    wattroff(game_win, COLOR_PAIR(COLOR_ENEMY));
    
    mvwprintw(game_win, start_y + 6, start_x + 2, "â³ ìƒëŒ€ë°©ì´ ê²Œì„ì„ ëë‚¼ ë•Œê¹Œì§€ ëŒ€ê¸° ì¤‘");
    wattroff(game_win, COLOR_PAIR(COLOR_UI));
    
    // ì• ë‹ˆë©”ì´ì…˜ìš© ì ë“¤
    static int dot_count = 0;
    dot_count = (dot_count + 1) % 4;
    wattron(game_win, COLOR_PAIR(COLOR_UI));
    for (int i = 0; i < dot_count; i++) {
        wprintw(game_win, ".");
    }
    wattroff(game_win, COLOR_PAIR(COLOR_UI));
}

// ê²Œì„ ì˜ì—­ë§Œ ê·¸ë¦¬ê¸° (ìƒ‰ìƒ ì ìš©ëœ ë²„ì „)
void draw_game_area() {
    
    // ëŒ€ê¸° ì¤‘ì´ë©´ ëŒ€ê¸° í™”ë©´ ê·¸ë¦¬ê¸°
    if (waiting_for_opponent) {
        draw_waiting_screen();
        return;
    }
    for (int y = 1; y < HEIGHT - 1; y++) {
        for (int x = 1; x < WIDTH - 1; x++) {
            mvwprintw(game_win, y, x, " ");
        }
    }
    // ê²Œì„ ìœˆë„ìš° í´ë¦¬ì–´
    werase(game_win);
    
    wattron(game_win, COLOR_PAIR(COLOR_BORDER));
    for (int i = 0; i < WIDTH; i++) {
        mvwprintw(game_win, 0, i, "â•");
        mvwprintw(game_win, HEIGHT - 1, i, "â•");
    }
    for (int i = 0; i < HEIGHT; i++) {
        mvwprintw(game_win, i, 0, "â•‘");
        mvwprintw(game_win, i, WIDTH - 1, "â•‘");
    }
    // ëª¨ì„œë¦¬
    mvwprintw(game_win, 0, 0, "â•”");
    mvwprintw(game_win, 0, WIDTH - 1, "â•—");
    mvwprintw(game_win, HEIGHT - 1, 0, "â•š");
    mvwprintw(game_win, HEIGHT - 1, WIDTH - 1, "â•");
    wattroff(game_win, COLOR_PAIR(COLOR_BORDER));
    
    // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸° (ì²­ë¡ìƒ‰ ìš°ì£¼ì„ )
    wattron(game_win, COLOR_PAIR(COLOR_PLAYER) | A_BOLD);
    mvwprintw(game_win, player_y, player_x, "A");
    wattroff(game_win, COLOR_PAIR(COLOR_PLAYER) | A_BOLD);
    
    // ë°œì‚¬ì²´ ê·¸ë¦¬ê¸° (ë…¸ë€ìƒ‰ ì´ì•Œ)
    wattron(game_win, COLOR_PAIR(COLOR_BULLET) | A_BOLD);
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (bullets[i].active)
            mvwprintw(game_win, bullets[i].y, bullets[i].x, "|");
    }
    wattroff(game_win, COLOR_PAIR(COLOR_BULLET) | A_BOLD);
    
    // ì¥ì• ë¬¼ ê·¸ë¦¬ê¸° (ë¹¨ê°„ìƒ‰ ì )
    wattron(game_win, COLOR_PAIR(COLOR_OBSTACLE) | A_BOLD);
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        if (obstacles[i].active)
            mvwprintw(game_win, obstacles[i].y, obstacles[i].x, "O");
    }
    wattroff(game_win, COLOR_PAIR(COLOR_OBSTACLE) | A_BOLD);
    
    
    // ì•„ì´í…œ ê·¸ë¦¬ê¸° (í¬ê¸° í™•ëŒ€)
    for (int i = 0; i < MAX_ITEMS; i++) {
        if (items[i].active) {
            if (items[i].type == ITEM_TYPE_CLEAR_MAP) {
                wattron(game_win, COLOR_PAIR(COLOR_ITEM) | A_BOLD);
                // 3x3 í¬ê¸°ë¡œ í™•ëŒ€
                mvwprintw(game_win, items[i].y-1, items[i].x-1, "âœ§âœ¦âœ§");
                mvwprintw(game_win, items[i].y,   items[i].x-1, "âœ¦âœ¦âœ¦");
                mvwprintw(game_win, items[i].y+1, items[i].x-1, "âœ§âœ¦âœ§");
                wattroff(game_win, COLOR_PAIR(COLOR_ITEM) | A_BOLD);
            } else if (items[i].type == ITEM_TYPE_BOMB) {
                wattron(game_win, COLOR_PAIR(COLOR_BOMB) | A_BOLD);
                // 3x3 í¬ê¸°ë¡œ í™•ëŒ€
                mvwprintw(game_win, items[i].y-1, items[i].x-1, "OOO");
                mvwprintw(game_win, items[i].y,   items[i].x-1, "OBO");
                mvwprintw(game_win, items[i].y+1, items[i].x-1, "OOO");
                wattroff(game_win, COLOR_PAIR(COLOR_BOMB) | A_BOLD);
            }
        }
    }

    // í­íƒ„ ì´í™íŠ¸ ê·¸ë¦¬ê¸° ë¶€ë¶„ ìˆ˜ì •
    // í­íƒ„ ì´í™íŠ¸ ê·¸ë¦¬ê¸°
    for (int i = 0; i < 5; i++) {
        if (bomb_effects[i].active) {
            wattron(game_win, COLOR_PAIR(COLOR_BOMB) | A_BOLD);
            int x = bomb_effects[i].x;
            int y = bomb_effects[i].y;
            int r = bomb_effects[i].radius; // 5ë°° ê³±í•˜ê¸° ì œê±°

            // ì •ì‚¬ê°í˜• ëª¨ì–‘ í­ë°œ ì´í™íŠ¸
            for (int dy = -r; dy <= r; dy++) {
                for (int dx = -r; dx <= r; dx++) {
                    int nx = x + dx;
                    int ny = y + dy;
                    if (nx > 0 && nx < WIDTH - 1 && ny > 0 && ny < HEIGHT - 1) {
                        mvwprintw(game_win, ny, nx, "*");
                    }
                }
            }

            // ì¤‘ì‹¬ë¶€ëŠ” ë” í™”ë ¤í•˜ê²Œ
            mvwprintw(game_win, y, x, "ğŸ’¥");
            wattroff(game_win, COLOR_PAIR(COLOR_BOMB) | A_BOLD);
        }
    }
    
    // ë¼ì´í”„ í‘œì‹œ (ë¹¨ê°„ìƒ‰ í•˜íŠ¸)
    wattron(game_win, COLOR_PAIR(COLOR_LIFE) | A_BOLD);
    mvwprintw(game_win, 1, WIDTH - 18, "Life: ");
    for (int i = 0; i < life; i++) {
        wprintw(game_win, "â™¥");
    }
    wattroff(game_win, COLOR_PAIR(COLOR_LIFE) | A_BOLD);
}

// UI ì˜ì—­ë§Œ ê·¸ë¦¬ê¸° (í–¥ìƒëœ ë²„ì „)
void draw_ui_area() {
    int current_score;
    int current_opponent_score;
    pthread_mutex_lock(&score_mutex);
    current_score = score;
    pthread_mutex_unlock(&score_mutex);
    
    pthread_mutex_lock(&network_mutex);
    current_opponent_score = opponent_score;
    pthread_mutex_unlock(&network_mutex);

    // ì ìˆ˜ê°€ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ UI ì—…ë°ì´íŠ¸
    if (current_score != last_score || current_opponent_score != last_opponent_score) {
        werase(ui_win);
        
        // UI í…Œë‘ë¦¬
        wattron(ui_win, COLOR_PAIR(COLOR_BORDER));
        for (int i = 0; i < 33; i++) {
            mvwprintw(ui_win, 0, i, "â•");
        }
        mvwprintw(ui_win, 0, 0, "â•”");
        mvwprintw(ui_win, 0, 32, "â•—");
        for (int i = 1; i < HEIGHT - 1; i++) {
            mvwprintw(ui_win, i, 0, "â•‘");
            mvwprintw(ui_win, i, 32, "â•‘");
        }
        for (int i = 0; i < 33; i++) {
            mvwprintw(ui_win, HEIGHT - 1, i, "â•");
        }
        mvwprintw(ui_win, HEIGHT - 1, 0, "â•š");
        mvwprintw(ui_win, HEIGHT - 1, 32, "â•");
        wattroff(ui_win, COLOR_PAIR(COLOR_BORDER));
        
        //ê²Œì„ëª¨ë“œì— ë”°ë¼ í‘œì‹œ
        wattron(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        if (current_game_mode == GAME_MODE_SINGLE) {
            mvwprintw(ui_win, 1, 2, "ğŸ¯ == 1ì¸ ëª¨ë“œ ==");
        } else {
            mvwprintw(ui_win, 1, 2, "ğŸ® == 2ì¸ ëª¨ë“œ ==");
            wattron(ui_win, COLOR_PAIR(COLOR_SCORE));
            mvwprintw(ui_win, 2, 2, "Seed: %d", seed);
            wattroff(ui_win, COLOR_PAIR(COLOR_SCORE));
        }
        wattroff(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);

        wattron(ui_win, COLOR_PAIR(COLOR_PLAYER) | A_BOLD);
        mvwprintw(ui_win, 3, 2, "ğŸš€ SPACE ESCAPE ğŸš€");
        wattroff(ui_win, COLOR_PAIR(COLOR_PLAYER) | A_BOLD);

        // ê²Œì„ ìƒíƒœ ì •ë³´
        wattron(ui_win, COLOR_PAIR(COLOR_LIFE) | A_BOLD);
        mvwprintw(ui_win, 5, 2, "â™¥ Life: %-2d", life);
        wattroff(ui_win, COLOR_PAIR(COLOR_LIFE) | A_BOLD);
        
        wattron(ui_win, COLOR_PAIR(COLOR_SCORE) | A_BOLD);
        mvwprintw(ui_win, 6, 2, "ğŸ’« Score: %-2d", current_score);
        wattroff(ui_win, COLOR_PAIR(COLOR_SCORE) | A_BOLD);
        
        wattron(ui_win, COLOR_PAIR(COLOR_BULLET));
        mvwprintw(ui_win, 7, 2, "ğŸ¯ Bullet: %-2d", MAX_BULLETS);
        wattroff(ui_win, COLOR_PAIR(COLOR_BULLET));
        
        wattron(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        mvwprintw(ui_win, 8, 2, "â­ LEVEL: %-2d", level);
        wattroff(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);

        // ì•„ì´í…œ ìƒíƒœ í‘œì‹œ
        wattron(ui_win, COLOR_PAIR(COLOR_BOMB) | A_BOLD);
        mvwprintw(ui_win, 9, 2, "ğŸ’£ Bomb: %s", has_bomb ? "READY" : "NONE");
        wattroff(ui_win, COLOR_PAIR(COLOR_BOMB) | A_BOLD);

        // ì»¨íŠ¸ë¡¤ ê°€ì´ë“œ (IMU ì»¨íŠ¸ë¡¤ëŸ¬ ê¸°ë°˜)
        wattron(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        mvwprintw(ui_win, 11, 2, "ğŸ® [ Controls ]");
        wattroff(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        
        wattron(ui_win, COLOR_PAIR(COLOR_PLAYER));
        if (controller_available) {
            // IMU ì»¨íŠ¸ë¡¤ëŸ¬ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ê²½ìš°
            mvwprintw(ui_win, 12, 2, "Move: IMU Sensor");
            mvwprintw(ui_win, 13, 2, "      â†– â†‘ â†—");
            mvwprintw(ui_win, 14, 2, "      â† â— â†’");
            mvwprintw(ui_win, 15, 2, "      â†™ â†“ â†˜");
            mvwprintw(ui_win, 16, 2, "Shoot: Button Press");
            mvwprintw(ui_win, 17, 2, "Bomb:  Button 3");
            mvwprintw(ui_win, 18, 2, "Exit:  Ctrl+C");
        } else {
            // í‚¤ë³´ë“œ ëª¨ë“œì¸ ê²½ìš°
            mvwprintw(ui_win, 12, 2, "Move: Numpad 1~9");
            mvwprintw(ui_win, 13, 2, "      â†– â†‘ â†—");
            mvwprintw(ui_win, 14, 2, "      â† 5 â†’");
            mvwprintw(ui_win, 15, 2, "      â†™ â†“ â†˜");
            mvwprintw(ui_win, 16, 2, "Shoot: [Space]");
            mvwprintw(ui_win, 17, 2, "Bomb:  [b]");
            mvwprintw(ui_win, 18, 2, "Exit:  Ctrl+C");
        }
        wattroff(ui_win, COLOR_PAIR(COLOR_PLAYER));
        
        // ì•„ì´í…œ ì„¤ëª…
        wattron(ui_win, COLOR_PAIR(COLOR_ITEM));
        mvwprintw(ui_win, 20, 2, "âœ¦ Clear Map Item");
        wattroff(ui_win, COLOR_PAIR(COLOR_ITEM));
        wattron(ui_win, COLOR_PAIR(COLOR_BOMB));
        mvwprintw(ui_win, 21, 2, "ğŸ’£ Bomb Item");
        wattroff(ui_win, COLOR_PAIR(COLOR_BOMB));
        
        //2ì¸ ëª¨ë“œì¼ ë•Œ ì¶”ê°€ ì •ë³´ í‘œì‹œ
        if (current_game_mode == GAME_MODE_MULTI) {
            wattron(ui_win, COLOR_PAIR(COLOR_ENEMY) | A_BOLD);
            mvwprintw(ui_win, 22, 2, "âš”ï¸ Opponent: %-2d", current_opponent_score);
            wattroff(ui_win, COLOR_PAIR(COLOR_ENEMY) | A_BOLD);
        }


        if (waiting_for_opponent) {
            wattron(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
            mvwprintw(ui_win, 21, 2, "â³ Status: Waiting...");
            wattroff(ui_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
        }
        
        // ë””ë²„ê·¸ ì •ë³´
        wattron(ui_win, COLOR_PAIR(COLOR_UI));
        mvwprintw(ui_win, 24, 2, "Controller: %s", debug_init_controller ? "âœ“" : "âœ—");
        mvwprintw(ui_win, 25, 2, "Direction: %c", imu_direction[0]);
        wattroff(ui_win, COLOR_PAIR(COLOR_UI));

        last_score = current_score;
        last_opponent_score = current_opponent_score;
    }
}

//ì¥ì• ë¬¼ ìƒì„± -> LEVELì´ ì¦ê°€í• ìˆ˜ë¡ ë¹ ë¥´ê²Œ ìƒì„±ë˜ê±°ë‚˜ ë‚´ë ¤ì˜¤ë„ë¡
void spawn_obstacle() {
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        if (!obstacles[i].active) {
            obstacles[i].active = 1;
            obstacles[i].x = rand() % (WIDTH - 22) + 1;
            obstacles[i].y = 1;
            break;
        }
    }
}

void update_bullets() {
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (bullets[i].active) {
            bullets[i].y--;
            if (bullets[i].y <= 0)
                bullets[i].active = 0;
        }
    }
}

void update_obstacles() {
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        if (obstacles[i].active) {
            obstacles[i].y++;
            if (obstacles[i].y >= HEIGHT - 2) {
                life--;
                obstacles[i].active = 0;
                if (life <= 0){
                    game_over = 1;
                    if(current_game_mode == GAME_MODE_SINGLE){
                        extern volatile int game_result_received;
                        game_result_received = 1;
                    }
                } 
            }
        }
    }
}

//mutexì‚¬ìš©, scoreë³´í˜¸
void check_collisions() {
    for (int i = 0; i < MAX_OBSTACLES; i++) {
        if (!obstacles[i].active) continue;
        for (int j = 0; j < MAX_BULLETS; j++) {
            if (bullets[j].active &&
                bullets[j].x == obstacles[i].x &&
                bullets[j].y == obstacles[i].y) {
                bullets[j].active = 0;
                obstacles[i].active = 0;
                pthread_mutex_lock(&score_mutex);
                score += 10;
                pthread_mutex_unlock(&score_mutex);
                break;
            }
        }
    }
}
// // ì•„ì´í…œê³¼ í”Œë ˆì´ì–´ ì¶©ëŒ ê²€ì‚¬ ë° ì²˜ë¦¬ í•¨ìˆ˜ ì¶”ê°€
// void check_item_collision() {
//     for (int i = 0; i < MAX_ITEMS; i++) {
//         if (items[i].active && 
//             items[i].x == player_x && 
//             items[i].y == player_y) {
            
//             items[i].active = 0;  // ì•„ì´í…œ ë¹„í™œì„±í™”
            
//             if (items[i].type == ITEM_TYPE_CLEAR_MAP) {
//                 // ë§µ í´ë¦¬ì–´ ì•„ì´í…œ íš¨ê³¼
//                 for (int j = 0; j < MAX_OBSTACLES; j++) {
//                     if (obstacles[j].active) {
//                         obstacles[j].active = 0;
//                         pthread_mutex_lock(&score_mutex);
//                         score += 5;  // í´ë¦¬ì–´ëœ ì¥ì• ë¬¼ë‹¹ 5ì 
//                         pthread_mutex_unlock(&score_mutex);
//                     }
//                 }
//             } else if (items[i].type == ITEM_TYPE_BOMB) {
//                 // í­íƒ„ ì•„ì´í…œ íšë“
//                 has_bomb = 1;
//             }
//             break;
//         }
//     }
// }

void check_item_collision() {
    for (int i = 0; i < MAX_ITEMS; i++) {
        if (items[i].active) {
            // 3x3 ì•„ì´í…œê³¼ì˜ ì¶©ëŒ ê²€ì‚¬
            // ì•„ì´í…œ ì˜ì—­: (x-1, y-1) ~ (x+1, y+1)
            if (player_x >= items[i].x - 1 && player_x <= items[i].x + 1 &&
                player_y >= items[i].y - 1 && player_y <= items[i].y + 1) {
                
                items[i].active = 0;  // ì•„ì´í…œ ë¹„í™œì„±í™”
                
                if (items[i].type == ITEM_TYPE_CLEAR_MAP) {
                    // ë§µ í´ë¦¬ì–´ ì•„ì´í…œ íš¨ê³¼
                    for (int j = 0; j < MAX_OBSTACLES; j++) {
                        if (obstacles[j].active) {
                            obstacles[j].active = 0;
                            pthread_mutex_lock(&score_mutex);
                            score += 5;
                            pthread_mutex_unlock(&score_mutex);
                        }
                    }
                } else if (items[i].type == ITEM_TYPE_BOMB) {
                    // í­íƒ„ ì•„ì´í…œ íšë“
                    has_bomb = 1;
                }
                break;
            }
        }
    }
}

void handle_input() {


    
    
    //ëŒ€ê¸° ì¤‘ì´ë©´ ì…ë ¥ ë¬´ì‹œ
    if (waiting_for_opponent) {
        wgetch(game_win); // ì…ë ¥ ë²„í¼ ë¹„ìš°ê¸°
        return;
    }

    if(controller_available){
        pthread_mutex_lock(&imu_lock);
        char ch = imu_direction[0];
        pthread_mutex_unlock(&imu_lock);
    
        pthread_mutex_lock(&switch_lock);
        char ch2 = imu_direction[1];
        char ch3 = imu_direction[2];
        pthread_mutex_unlock(&switch_lock);
        if (ch == ERR) return;
        switch (ch) {
            case '7':  // â†–
                if (player_x > 1) player_x--;
                if (player_y > 1) player_y--;
                break;
            case '8':  // â†‘
                if (player_y > 1) player_y--;
                break;
            case '9':  // â†—
                if (player_x < WIDTH - 2) player_x++;
                if (player_y > 1) player_y--;
                break;
            case '4':  // â†
                if (player_x > 1) player_x--;
                break;
            case '5':  // ì •ì§€ (ì‚¬ìš© X)
                break;
            case '6':  // â†’
                if (player_x < WIDTH - 2) player_x++;
                break;
            case '1':  // â†™
                if (player_x > 1) player_x--;
                if (player_y < HEIGHT - 2) player_y++;
                break;
            case '2':  // â†“
                if (player_y < HEIGHT - 2) player_y++;
                break;
            case '3':  // â†˜
                if (player_x < WIDTH - 2) player_x++;
                if (player_y < HEIGHT - 2) player_y++;
                break;
            case ' ':
                for (int i = 0; i < MAX_BULLETS; i++) {
                    if (!bullets[i].active) {
                        bullets[i].active = 1;
                        bullets[i].x = player_x;
                        bullets[i].y = player_y - 1;
                        break;
                    }
                }
                break;
            case 'p':
                paused = !paused;
                break;
            default:
                break;
        }
    
        // ë°œì‚¬ ë²„íŠ¼ (ch2)
        switch(ch2){
            case '1':
                for (int i = 0; i < MAX_BULLETS; i++) {
                    if (!bullets[i].active) {
                        bullets[i].active = 1;
                        bullets[i].x = player_x;
                        bullets[i].y = player_y - 1;
                        break;
                    }
                }
                break;
        }
    
        // í­íƒ„ ì‚¬ìš© ë²„íŠ¼ (ch3)
        switch(ch3){
        // í­íƒ„ ì‚¬ìš© ë¶€ë¶„ ìˆ˜ì • (handle_input í•¨ìˆ˜ ë‚´)
            case '1':
                if (has_bomb) {  // í­íƒ„ì„ ë³´ìœ í•˜ê³  ìˆì„ ë•Œë§Œ
                    // í”Œë ˆì´ì–´ ìœ„ì¹˜ì—ì„œ í­íƒ„ ì´í™íŠ¸ ìƒì„±
                    create_bomb_effect(player_x, player_y);
                    
                    // í­íƒ„ ë°˜ê²½ ë‚´ ì¥ì• ë¬¼ íŒŒê´´ (ë°˜ê²½ì„ 5ë¡œ í†µì¼)
                    destroy_obstacles_in_bomb_range(player_x, player_y, 12);
                    
                    // í­íƒ„ ì‚¬ìš© ì™„ë£Œ
                    has_bomb = 0;
                }
                break;
        }

    } else{
        char ch;
        ch  = wgetch(game_win);
        if(ch == ERR) return;
        switch (ch) {
            case '7':  // â†–
            if (player_x > 1) player_x--;
            if (player_y > 1) player_y--;
            break;
            case '8':  // â†‘
                if (player_y > 1) player_y--;
                break;
            case '9':  // â†—
                if (player_x < WIDTH - 2) player_x++;
                if (player_y > 1) player_y--;
                break;
            case '4':  // â†
                if (player_x > 1) player_x--;
                break;
            case '5':  // ì •ì§€ (ì‚¬ìš© X)
                break;
            case '6':  // â†’
                if (player_x < WIDTH - 2) player_x++;
                break;
            case '1':  // â†™
                if (player_x > 1) player_x--;
                if (player_y < HEIGHT - 2) player_y++;
                break;
            case '2':  // â†“
                if (player_y < HEIGHT - 2) player_y++;
                break;
            case '3':  // â†˜
                if (player_x < WIDTH - 2) player_x++;
                if (player_y < HEIGHT - 2) player_y++;
                break;
            case ' ':
                for (int i = 0; i < MAX_BULLETS; i++) {
                    if (!bullets[i].active) {
                        bullets[i].active = 1;
                        bullets[i].x = player_x;
                        bullets[i].y = player_y - 1;
                        break;
                    }
                }
                break;
            case 'b':
                if (has_bomb) {
                    create_bomb_effect(player_x, player_y);
                    destroy_obstacles_in_bomb_range(player_x, player_y, 12);
                    has_bomb = 0;
                }
                break;
            case 'p':
                paused = !paused;
                break;
            default:
                break;
        }
    }
    
    //if (ch == ERR) return;  // ì…ë ¥ì´ ì—†ìœ¼ë©´ ë°”ë¡œ ë¦¬í„´

    
}

// run_game() í•¨ìˆ˜ ìˆ˜ì •
void* run_game(void* arg) {
    (void)arg;
    setlocale(LC_ALL, "");

    // ê²Œì„ ì´ˆê¸°í™”
    init_game();
    init_controller();
    int frame = 0;
    
    // ê²Œì„ ë£¨í”„ (ë£¨í”„ í•œë²ˆ ëŒë•Œë§ˆë‹¤ frameì´ ì¦ê°€í•¨.)
    extern volatile int game_result_received;

    while (!game_result_received) { //network.cì˜ handle_game_resultê¹Œì§€ (ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ê°€ ëë‚˜ì•¼ë§Œ í˜¸ì¶œë¨)
        if (!paused) {
            //ë Œë”ë§ ë®¤í…ìŠ¤ë¡œ ë³´í˜¸
            pthread_mutex_lock(&render_mutex);

            //ê²Œì„ì´ ëë‚¬ì§€ë§Œ ì•„ì§ ê²°ê³¼ë¥¼ ë°›ì§€ ëª»í•œ ê²½ìš°
            if (game_over && current_game_mode == GAME_MODE_MULTI && !waiting_for_opponent) {
                waiting_for_opponent = 1;  //ëŒ€ê¸° ìƒíƒœë¡œ ì „í™˜
            }
            //ëŒ€ê¸° ì¤‘ì´ ì•„ë‹ë• ë™ì‘ì œì–´ê°€ëŠ¥
            if (!waiting_for_opponent) {
                handle_input();
                update_bullets();
                
                if (frame % obstacle_interval == 0) update_obstacles();
                if (frame % spawn_interval == 0) spawn_obstacle();
                if (frame % spawn_interval == 0) spawn_item();
                
                // ì•„ì´í…œ ê´€ë ¨ ì—…ë°ì´íŠ¸ ì¶”ê°€
                if (frame % 30 == 0) spawn_item();  // 30í”„ë ˆì„ë§ˆë‹¤ ì•„ì´í…œ ìƒì„± ì‹œë„
                if(frame % 15 == 0) update_items();                     // ì•„ì´í…œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                check_item_collision();             // ì•„ì´í…œê³¼ í”Œë ˆì´ì–´ ì¶©ëŒ ê²€ì‚¬
                
                // í­íƒ„ ì´í™íŠ¸ ì—…ë°ì´íŠ¸ ì¶”ê°€
                update_bomb_effects();
                
                check_collisions();
                
                frame++;
                
                // ë ˆë²¨ì—… ì¡°ê±´
                if (frame % 500 == 0) {
                    level++;
                    obstacle_interval = (obstacle_interval > 5) ? obstacle_interval - 2 : 5;
                    spawn_interval = (spawn_interval > 3) ? spawn_interval - 1 : 3;
                }
            } else {
                // ëŒ€ê¸° ì¤‘ì—ë„ ì…ë ¥ì€ ì²˜ë¦¬ (ë²„í¼ ë¹„ìš°ê¸° ìœ„í•´)
                handle_input();
            }

            // í™”ë©´ ê·¸ë¦¬ê¸° (ëŒ€ê¸° ì¤‘ì´ë“  ì•„ë‹ˆë“ )
            draw_game_area();
            draw_ui_area();

            // ìœˆë„ìš° ìƒˆë¡œê³ ì¹¨
            wnoutrefresh(game_win);
            wnoutrefresh(ui_win);
            doupdate();

            pthread_mutex_unlock(&render_mutex);
        } else {
            pthread_mutex_lock(&render_mutex);
            
            // ì¼ì‹œì •ì§€ í™”ë©´ì„ ë” ì˜ˆì˜ê²Œ í‘œì‹œ
            int pause_x = WIDTH / 2 - 10;
            int pause_y = HEIGHT / 2 - 3;
            
            wattron(game_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
            mvwprintw(game_win, pause_y, pause_x, "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            mvwprintw(game_win, pause_y + 1, pause_x, "â•‘                  â•‘");
            mvwprintw(game_win, pause_y + 2, pause_x, "â•‘   â¸ï¸  PAUSED    â•‘");
            mvwprintw(game_win, pause_y + 3, pause_x, "â•‘                  â•‘");
            mvwprintw(game_win, pause_y + 4, pause_x, "â•‘  Press 'p' to    â•‘");
            mvwprintw(game_win, pause_y + 5, pause_x, "â•‘    continue      â•‘");
            mvwprintw(game_win, pause_y + 6, pause_x, "â•‘                  â•‘");
            mvwprintw(game_win, pause_y + 7, pause_x, "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            wattroff(game_win, COLOR_PAIR(COLOR_UI) | A_BOLD);
            
            wnoutrefresh(game_win);
            doupdate();
            pthread_mutex_unlock(&render_mutex);
        }
        usleep(30000);
    }
    
    end_game();
    join_thread(imu_thread);
    return NULL;
}
